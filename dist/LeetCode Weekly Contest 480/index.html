<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>LeetCode Weekly Contest 480 | 文章列表</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
  <link rel="stylesheet" href="../assets/highlight-github.min.css" />
  <link rel="stylesheet" href="../assets/style.css" />
  <script src="../assets/code-tabs.js" defer></script>
  <script src="../assets/theme-toggle.js" defer></script>
  <script src="../assets/lang-toggle.js" defer></script>
  <script src="../assets/toc.js" defer></script>
</head>
<body>
  <div class="page">
    <header class="hero">
      <div class="hero__controls">
        <div class="theme-toggle">
          <button type="button" id="theme-toggle" aria-label="切換主題">
            <span class="theme-toggle__track">
              <svg class="theme-toggle__icon theme-toggle__icon--sun" viewBox="0 0 24 24" aria-hidden="false">
                <circle cx="12" cy="12" r="5" stroke="currentColor" stroke-width="2" fill="none" />
                <path d="M12 2v2m0 16v2M4.93 4.93l1.41 1.41m11.32 11.32l1.41 1.41M2 12h2m16 0h2M4.93 19.07l1.41-1.41m11.32-11.32l1.41-1.41" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" />
              </svg>
              <svg class="theme-toggle__icon theme-toggle__icon--moon" viewBox="0 0 24 24" aria-hidden="true">
                <path d="M21 12.79A9 9 0 0 1 11.21 3 7 7 0 1 0 21 12.79Z" stroke="currentColor" stroke-width="2" fill="none" stroke-linecap="round" stroke-linejoin="round" />
              </svg>
              <span class="theme-toggle__thumb"></span>
            </span>
          </button>
        </div>
        <div class="lang-switch">
          <select id="lang-select" aria-label="Language">
            <option value="zh" selected>中文</option>
            <option value="en" >English</option>
          </select>
        </div>
      </div>
      <div class="hero__text hero__text--clickable" data-home="/" role="button" tabindex="0" aria-label="← 返回列表">
        <h1>文章列表</h1>
      </div>
    </header>

    <main class="layout layout--with-toc">
      <article class="reader">
        <a class="back-link" href="/">← 返回列表</a>
        <h1>LeetCode Weekly Contest 480</h1>
        <p class="date">
          2025-12-20
          
            ·
            
              <span class="tag">演算法</span> 
            
              <span class="tag">LeetCode</span> 
            
              <span class="tag">線段樹</span>
            
          
        </p>
        <div class="article-body"><p>這是我第一次在 LeetCode 週賽 AK，寫完非常地開心，雖然我覺得第四題 Hard 只是在線段樹的模板上加一些修改，有點水，但還是想說來記錄一下。</p>
<ul>
<li><strong>Rank: 598 / 30007</strong></li>
<li><strong>Rating: 1752 -&gt; 1824 (+72)</strong></li>
</ul>
<h3 id="asueffeeeeweeauaueees">Absolute Difference Between Maximum and Minimum K Elements</h3>\n<p>排序後把最大 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 個數字總和減掉最小 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 個數字總和就結束。</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// 0 ms, Beats 100 %</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">absDifference</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums, <span class="hljs-type">int</span> k)</span> </span>{
        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>(), large = <span class="hljs-number">0</span>, small = <span class="hljs-number">0</span>;
        <span class="hljs-built_in">sort</span>(nums.<span class="hljs-built_in">begin</span>(), nums.<span class="hljs-built_in">end</span>());
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) {
            small += nums[i];
            large += nums[n - i - <span class="hljs-number">1</span>];
        }
        <span class="hljs-keyword">return</span> large - small;
    }
};</code></pre><h3 id="eesewswsaeweu">Reverse Words With Same Vowel Count</h3>\n<p>一樣是暴力題，只是我為了讓字串最後一個字也能正確判到，因此在實作上先<strong>把 s 最後面加上一個 space</strong>，做完再把它刪除掉。</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// 19 ms, Beats 87.99 %</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">string <span class="hljs-title">reverseWords</span><span class="hljs-params">(string s)</span> </span>{
        s += <span class="hljs-string">&#x27; &#x27;</span>;
        <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();
        <span class="hljs-type">int</span> check = <span class="hljs-number">-1</span>, past = <span class="hljs-number">-1</span>, cnt = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27; &#x27;</span>) {
                <span class="hljs-keyword">if</span> (check == <span class="hljs-number">-1</span>) {
                    check = cnt;
                }
                <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt == check) {
                    <span class="hljs-built_in">reverse</span>(s.<span class="hljs-built_in">begin</span>() + past + <span class="hljs-number">1</span>, s.<span class="hljs-built_in">begin</span>() + i);
                }
                past = i, cnt = <span class="hljs-number">0</span>;
                <span class="hljs-keyword">continue</span>;
            }
            <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;a&#x27;</span> || s[i] == <span class="hljs-string">&#x27;e&#x27;</span> || s[i] == <span class="hljs-string">&#x27;i&#x27;</span> || s[i] == <span class="hljs-string">&#x27;o&#x27;</span> || s[i] == <span class="hljs-string">&#x27;u&#x27;</span>) ++cnt;
        }
        s.<span class="hljs-built_in">pop_back</span>();
        <span class="hljs-keyword">return</span> s;
    }
};</code></pre><h3 id="uesaaeuaaa">Minimum Moves to Balance Circular Array</h3>\n<p>這題要挪動數字直到所有數字都是非負，且最多存在一個負數。首先要先嘗試把這個負數找出來，如果陣列中不存在任何負數（找不到），那當然不需要挪動，答案是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">0</span></span></span></span>。在挪動時因為挪一格就算一步，因此理所當然<strong>優先拿離負數較近的</strong>。考量到長度為 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 的環形陣列，離每一個 index 最遠的距離會是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> ，因此從距離 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">1</span></span></span></span> 到距離 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 的順序拿元素來補，值得一提的是在每個距離都會有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">2</span></span></span></span> 個元素可以拿，但在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.4306em;"></span><span class="mord mathnormal">n</span></span></span></span> 是偶數的狀況下，距離 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi><mi mathvariant="normal">/</mi><mn>2</mn></mrow><annotation encoding="application/x-tex">n/2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">n</span><span class="mord">/2</span></span></span></span> 的元素只會有一個，因此在計算時要避免重複計算到。</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// 0 ms, Beats 100 %</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">minMoves</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; balance)</span> </span>{
        <span class="hljs-type">int</span> n = balance.<span class="hljs-built_in">size</span>(), minus = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
            <span class="hljs-keyword">if</span> (balance[i] &lt; <span class="hljs-number">0</span>) {
                minus = i;
                <span class="hljs-keyword">break</span>;
            }
        }
        <span class="hljs-keyword">if</span> (minus == <span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
        <span class="hljs-type">int</span> steps = -balance[minus];
        <span class="hljs-type">long</span> <span class="hljs-type">long</span> res = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n&gt;&gt;<span class="hljs-number">1</span> ; i++) {
            <span class="hljs-type">int</span> curr = <span class="hljs-built_in">min</span>(steps, balance[(minus + i) % n]);
            res += <span class="hljs-number">1LL</span> * curr * i;
            steps -= curr;
            <span class="hljs-keyword">if</span> (i == n &gt;&gt; <span class="hljs-number">1</span> &amp;&amp; !(n &amp; <span class="hljs-number">1</span>)) <span class="hljs-keyword">break</span>;
            curr = <span class="hljs-built_in">min</span>(steps, balance[(minus - i + n) % n]);
            res += <span class="hljs-number">1LL</span> * curr * i;
            steps -= curr;
            <span class="hljs-keyword">if</span> (steps == <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
        }
        <span class="hljs-keyword">if</span> (steps &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">return</span> res;
    }
};</code></pre><h3 id="ueesaeaeasus">Minimum Deletions to Make Alternating Substring</h3>\n<p>這題一看到區間查詢我就覺得應該是線段樹了，一個由 <code>A</code> 和 <code>B</code> 組成的字串，要花多少次刪除操作才能使得字串中相鄰字元皆不相同。考慮到一個字串的答案可以分成 <strong>前半子字串的答案</strong> 加上 <strong>後半子字串的答案</strong>，如果在前<strong>半子字串最後一個字元與後半子字串第一個字元一樣</strong>的狀況下，答案還要加上 1，這題只需要在線段樹的分治後在加上一個判斷式就可以維護好每個區間的答案了。</p>
<pre><code class="hljs language-cpp"><span class="hljs-comment">// 116 ms, Beats 62.36 %</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">SegmentTree</span> {
<span class="hljs-keyword">private</span>:
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> lc 2 * id + 1</span>
    <span class="hljs-meta">#<span class="hljs-keyword">define</span> rc 2 * id + 2</span>
    string arr;
    <span class="hljs-type">int</span> n;
    vector&lt;<span class="hljs-type">int</span>&gt; seg;
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">build</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> id)</span></span>{
        <span class="hljs-keyword">if</span>(left == right){
            seg[id] = <span class="hljs-number">0</span>;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-built_in">build</span>(left, mid, lc);
        <span class="hljs-built_in">build</span>(mid + <span class="hljs-number">1</span>, right, rc);
        seg[id] = seg[lc] + seg[rc];
        <span class="hljs-keyword">if</span>(arr[mid] == arr[mid + <span class="hljs-number">1</span>]) ++seg[id];
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">modify</span><span class="hljs-params">(<span class="hljs-type">int</span> idx, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> id)</span></span>{
        <span class="hljs-keyword">if</span>(left == right){
            arr[left] = <span class="hljs-string">&#x27;B&#x27;</span> - arr[left] + <span class="hljs-string">&#x27;A&#x27;</span>;
            <span class="hljs-keyword">return</span>;
        }
        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(idx &lt;= mid){
            <span class="hljs-built_in">modify</span>(idx, left, mid, lc);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-built_in">modify</span>(idx, mid + <span class="hljs-number">1</span>, right, rc);
        }
        seg[id] = seg[lc] + seg[rc];
        <span class="hljs-keyword">if</span>(arr[mid] == arr[mid + <span class="hljs-number">1</span>]) ++seg[id];
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">query</span><span class="hljs-params">(<span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, <span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r, <span class="hljs-type">int</span> id)</span></span>{
        <span class="hljs-keyword">if</span>(l &lt;= left &amp;&amp; right &lt;= r){
            <span class="hljs-keyword">return</span> seg[id];
        }
        <span class="hljs-type">int</span> mid = (left + right) &gt;&gt; <span class="hljs-number">1</span>;
        <span class="hljs-keyword">if</span>(r &lt;= mid){
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, mid, l, r, lc);
        }
        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(l &gt; mid){
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, right, l, r, rc);
        }
        <span class="hljs-keyword">else</span>{
            <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(left, mid, l, r, lc) + <span class="hljs-built_in">query</span>(mid + <span class="hljs-number">1</span>, right, l, r, rc) + ((arr[mid] == arr[mid + <span class="hljs-number">1</span>]) ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);
        }
    }
<span class="hljs-keyword">public</span>:
    <span class="hljs-built_in">SegmentTree</span>(string s){
        arr = s;
        n = s.<span class="hljs-built_in">length</span>();
        seg.<span class="hljs-built_in">resize</span>(<span class="hljs-number">4</span> * n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
        <span class="hljs-built_in">build</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    }
    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">flip</span><span class="hljs-params">(<span class="hljs-type">int</span> idx)</span></span>{
        <span class="hljs-built_in">modify</span>(idx, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
    }
    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">compute</span><span class="hljs-params">(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> r)</span></span>{
        <span class="hljs-keyword">return</span> <span class="hljs-built_in">query</span>(<span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>, l, r, <span class="hljs-number">0</span>);
    }
};
<span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> {
<span class="hljs-keyword">public</span>:
    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">minDeletions</span><span class="hljs-params">(string s, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; queries)</span> </span>{
        <span class="hljs-function">SegmentTree <span class="hljs-title">tree</span><span class="hljs-params">(s)</span></span>;
        vector&lt;<span class="hljs-type">int</span>&gt; res;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> &amp;v : queries){
            <span class="hljs-keyword">if</span>(v[<span class="hljs-number">0</span>] == <span class="hljs-number">1</span>){
                tree.<span class="hljs-built_in">flip</span>(v[<span class="hljs-number">1</span>]);
            }
            <span class="hljs-keyword">else</span>{
                res.<span class="hljs-built_in">push_back</span>(tree.<span class="hljs-built_in">compute</span>(v[<span class="hljs-number">1</span>], v[<span class="hljs-number">2</span>]));
            }
        }
        <span class="hljs-keyword">return</span> res;
    }
};</code></pre></div>
      </article>
      
      <aside class="toc">
        <div class="toc__inner">
          <h3 class="toc__title">目錄</h3>
          <nav class="toc__nav">
            
              <a href="#absolute-difference-between-maximum-and-minimum-k-elements" class="toc__link toc__link--level-3">Absolute Difference Between Maximum and Minimum K Elements</a>
            
              <a href="#reverse-words-with-same-vowel-count" class="toc__link toc__link--level-3">Reverse Words With Same Vowel Count</a>
            
              <a href="#minimum-moves-to-balance-circular-array" class="toc__link toc__link--level-3">Minimum Moves to Balance Circular Array</a>
            
              <a href="#minimum-deletions-to-make-alternating-substring" class="toc__link toc__link--level-3">Minimum Deletions to Make Alternating Substring</a>
            
          </nav>
        </div>
      </aside>
      
    </main>

    <footer class="footer">
      <p>&copy; 2025. All rights reserved.</p>
    </footer>
  </div>
  <script>
    (() => {
      const el = document.querySelector(".hero__text--clickable");
      if (!el) return;
      const go = () => {
        const target = el.getAttribute("data-home") || "/";
        window.location.href = target;
      };
      el.addEventListener("click", go);
      el.addEventListener("keydown", (e) => {
        if (e.key === "Enter" || e.key === " ") {
          e.preventDefault();
          go();
        }
      });
    })();
  </script>
</body>
</html>
